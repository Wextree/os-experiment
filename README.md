# os-experiment
The homework of my os lesson

language：C



## 进程调度

> 单线程调度，循环方式实现运行，结点插入顺序模拟进程产生顺序，进程一次一起产生，进程时间随机分配（设有阈值）

- shortest：短进程优先，进程所有时间越短，优先级越高
- priority：响应比优先，优先级由进程所需时间和等待时间一起决定
- timep：时间片轮转，设置时间片大小，然后一直轮流运转，直到进程全部执行完毕



## 银行家算法

>  采用时间片轮转的进程算法，即不用考虑进程的优先级
>
> 利用银行家算法避免死锁
>
> 每次分配给某个进程某些资源时都要进行安全性检测
>
> 安全性检测通过，表示此次分配内存不会导致后面可能发生死锁，给予资源
>
> 安全性检测不通过，虽然可能不会造成死锁，但一律不给予分配

- 初始化进程。创建五个进程，给予名字还有所需要的最大资源的数额，并且将已分配的内存置为零。所需的最大资源在系统给的最大资源数内取得随机数。然后按照先后顺序插入就绪队列。

- 调用银行家算法，每次从就绪队列中获得队首进程。随机申请所缺资源的一部分资源，利用随机数表示。

-  申请资源与当前系统所拥有的的资源进行比较，如果系统资源不够分配，那么此进程进入阻塞队列，等到有进程完成后释放内存时再判断是否能够重新进入就绪队列排队。

- 如果资源足够分配给这个进程，就先试探性地给它分配资源，然后进行安全性检测。

- 安全性检测，从就绪队首开始检测，如果当前系统资源足够分给某个进程剩余的所需资源数，那么就收回这个进程已分配的资源数，标记这个进程不用再检测。然后重新从就绪队首进行遍历，直到有一遍遍历时没有任何一个资源可以回收时，返回安全检测失败。如果当前资源数到达系统本身拥有的资源数时，表示安全检测成功，不会发生死锁。

- 如果安全性检测失败，那么该进程可能会发生死锁，不给予内存上的分配，该进程插入到就绪队列尾部进行重新排队。

- 如果安全性检测成功，不可能造成死锁。系统资源给予分配所请求的数量的内存。然后判断此时该进程是否已经得到所有所需要的资源，如果是，拿表示改进程已经完成，释放该进程的已分配的资源数，插入到完成队列。

- 当有一个进程已经完成，遍历阻塞队列，取出所申请资源小于当前释放后的内存资源的进程，放入就绪队列尾部进行排队。

-  如果刚才有进程分配资源后并没有到达完成的状态，把该进程重新放入就绪队列尾部排队。



## 动态内存分配

>三个链表，一个申请释放进程序列，一个空闲区块序列，还有一个占用区块序列
>
>分别对应三个结构体

- first-allocation：首次适应算法，按照区块的地址从小到大检索，找到第一个满足进程内存需要的就插入
- best-allocation：最佳适应算法，按照区块大小从小到大进行检索，找到第一个满足进程内存需要的就插入

###首次适应算法和最佳适应算法相同流程：

-  初始化操作。通过input文件获取要求的申请操作信息，放到lst申请链表中。初始化空闲区块链和占用区块链。空闲区块链一开始只有一个结点，大小是一整个内存块，占用区块链没有内容，为NULL；

- 判断操作类型，1是申请，0是释放；

- 申请操作就是在空闲区块链中找到合适的空闲区块，然后减去进程所需要的内存数量。然后把进程的长度，进程号，占用内存的起始地址附给一个新建的占用内存块，然后将此块插入到占用区块链中。如果找不到适合的空闲区块就返回内存不够，撤回申请。

- 释放操作就是，按照释放的进程的信息，匹配占用区块链的信息，找到匹配的就删除该结点，然后就释放的内存加载空闲区块链的特定结点上。

###首次适应算法和最佳适应算法不同流程：

​       首次适应算法是找到空闲区里面第一个适合的区块就进行内存的分配。所以在空闲内存区块中是按开始地址从小到大进行排列的。其次就是首次适应算法释放内存时候需要整合操作，也就是释放内存时会有四种情况，无区块可以拼接，前拼接，后拼接，前后拼接。我对此的解决是直接按无拼接先放入空闲区块链里面，然后每次释放会对空闲区块进行一个整合操作，遍历空闲区块，然后把所有可以连接的区块全部连接起来。

​       最佳适应算法是找到空闲区块最小的可以适合这个进程的内存进行分配。这就要求我们对空闲区块链的结点按长度从小到大进行排序，那么当我们从左往右找到第一个符合的接待时，那它必定是最小的，最佳适应算法不需要对释放操作有多种情况的做法。





## 磁盘调度

- FCFS（先来先服务）：按进程命令到达的先后顺序进行读磁盘
- SSTS（寻道时间短优先）：距离现在磁头位置最近的先读磁盘
- SCAN（扫描算法）：按上一次磁头移动的方向找最短距离的进程，然后到最后方向转换过来继续找
- CSCAN（循环扫描算法）：按上一次磁头移动的方向找最短距离的进程，然后到最后又从头开始，以相同方向扫描